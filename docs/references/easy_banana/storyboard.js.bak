/* eslint-disable no-console */
document.addEventListener('DOMContentLoaded', () => {
  const rowsContainer = document.getElementById('storyRows');
  const rowTemplate = document.getElementById('storyboardRowTemplate');
  const downloadAllBtn = document.getElementById('storyDownloadAll');
  const downloadAllDefaultLabel = downloadAllBtn?.textContent || 'ZIP Download All';

  if (!rowsContainer || !rowTemplate) return;

  const rows = new Map();
  let rowSeq = 0;
  let storyboardModels = [];
  let modelsLoaded = false;
  let zipBusy = false;

  const CRC32_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i += 1) {
      let c = i;
      for (let k = 0; k < 8; k += 1) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function crc32(buffer) {
    let crc = -1;
    for (let i = 0; i < buffer.length; i += 1) {
      crc = CRC32_TABLE[(crc ^ buffer[i]) & 0xFF] ^ (crc >>> 8);
    }
    return (crc ^ -1) >>> 0;
  }

  function toDosDateTime(date = new Date()) {
    const year = Math.max(1980, date.getFullYear());
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = Math.floor(date.getSeconds() / 2);
    const dosDate = ((year - 1980) << 9) | (month << 5) | day;
    const dosTime = (hours << 11) | (minutes << 5) | seconds;
    return { date: dosDate & 0xFFFF, time: dosTime & 0xFFFF };
  }

  class ZipWriter {
    constructor() {
      this.parts = [];
      this.central = [];
      this.offset = 0;
      this.fileCount = 0;
      if (!ZipWriter.encoder) ZipWriter.encoder = new TextEncoder();
    }

    add(name, data, fileDate) {
      const input = data instanceof Uint8Array ? data : new Uint8Array(data);
      const encoder = ZipWriter.encoder;
      const nameBytes = encoder.encode(name);
      const dos = toDosDateTime(fileDate);
      const crc = crc32(input);
      const localOffset = this.offset;

      const localHeader = new Uint8Array(30 + nameBytes.length);
      const localView = new DataView(localHeader.buffer);
      localView.setUint32(0, 0x04034b50, true);
      localView.setUint16(4, 20, true);
      localView.setUint16(6, 0, true);
      localView.setUint16(8, 0, true);
      localView.setUint16(10, dos.time, true);
      localView.setUint16(12, dos.date, true);
      localView.setUint32(14, crc, true);
      localView.setUint32(18, input.length, true);
      localView.setUint32(22, input.length, true);
      localView.setUint16(26, nameBytes.length, true);
      localView.setUint16(28, 0, true);
      localHeader.set(nameBytes, 30);

      const centralHeader = new Uint8Array(46 + nameBytes.length);
      const centralView = new DataView(centralHeader.buffer);
      centralView.setUint32(0, 0x02014b50, true);
      centralView.setUint16(4, 20, true);
      centralView.setUint16(6, 20, true);
      centralView.setUint16(8, 0, true);
      centralView.setUint16(10, 0, true);
      centralView.setUint16(12, dos.time, true);
      centralView.setUint16(14, dos.date, true);
      centralView.setUint32(16, crc, true);
      centralView.setUint32(20, input.length, true);
      centralView.setUint32(24, input.length, true);
      centralView.setUint16(28, nameBytes.length, true);
      centralView.setUint16(30, 0, true);
      centralView.setUint16(32, 0, true);
      centralView.setUint16(34, 0, true);
      centralView.setUint16(36, 0, true);
      centralView.setUint32(38, 0, true);
      centralView.setUint32(42, localOffset, true);
      centralHeader.set(nameBytes, 46);

      this.parts.push(localHeader, input);
      this.central.push(centralHeader);
      this.offset += localHeader.length + input.length;
      this.fileCount += 1;
    }

    generate() {
      const centralOffset = this.offset;
      const centralSize = this.central.reduce((acc, part) => acc + part.length, 0);
      const endRecord = new Uint8Array(22);
      const endView = new DataView(endRecord.buffer);
      endView.setUint32(0, 0x06054b50, true);
      endView.setUint16(4, 0, true);
      endView.setUint16(6, 0, true);
      endView.setUint16(8, this.fileCount, true);
      endView.setUint16(10, this.fileCount, true);
      endView.setUint32(12, centralSize, true);
      endView.setUint32(16, centralOffset, true);
      endView.setUint16(20, 0, true);

      return new Blob([...this.parts, ...this.central, endRecord], { type: 'application/zip' });
    }
  }

  function hasDownloadableResults() {
    for (const entry of rows.values()) {
      const result = entry?.state?.result;
      if (!result) continue;
      if (result.type === 'video' && Array.isArray(result.videos) && result.videos.some((item) => item?.url)) return true;
      if (result.type === 'image' && Array.isArray(result.images) && result.images.some((item) => item && (item.src || item.dataUrl || item.url))) return true;
      if (result.type === 'audio' && Array.isArray(result.audios) && result.audios.some((item) => item && (item.src || item.dataUrl || item.url))) return true;
    }
    return false;
  }

  function refreshDownloadAllState() {
    if (!downloadAllBtn) return;
    downloadAllBtn.disabled = zipBusy || !hasDownloadableResults();
  }

  function setZipBusy(flag, label) {
    zipBusy = !!flag;
    if (downloadAllBtn) {
      downloadAllBtn.textContent = flag ? (label || 'ZIPを準備しています...') : downloadAllDefaultLabel;
    }
    refreshDownloadAllState();
  }

  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  function mergeLogs(current, incoming) {
    const base = Array.isArray(current) ? current.slice() : [];
    const seen = new Set(base);
    const next = Array.isArray(incoming) ? incoming : [];
    for (const line of next) {
      const text = typeof line === 'string' ? line.trim() : '';
      if (!text || seen.has(text)) continue;
      seen.add(text);
      base.push(text);
    }
    return base;
  }

  function getStatusString(data) {
    const fields = [data?.status, data?.queue_status, data?.state, data?.phase];
    for (const field of fields) {
      if (typeof field === 'string' && field.trim()) return field.trim();
    }
    return '';
  }

  function collectLogsFromData(data) {
    const sources = [
      data?.logs,
      data?.output?.logs,
      data?.result?.logs,
      data?.data?.logs,
      data?.debug?.logs,
      data?.queue?.logs
    ];
    const lines = [];
    const pushLine = (value) => {
      if (!value) return;
      if (Array.isArray(value)) {
        value.forEach(pushLine);
        return;
      }
      if (typeof value === 'string') {
        lines.push(value);
        return;
      }
      if (typeof value === 'object') {
        const msg = value.message || value.text || value.status || JSON.stringify(value);
        lines.push(msg);
      }
    };
    sources.forEach(pushLine);
    const message = data?.message || data?.detail || data?.note;
    if (typeof message === 'string') lines.push(message);
    return lines.map((line) => line.toString().trim()).filter(Boolean);
  }

  function collectExtraUrls(data) {
    const extras = new Set();
    const add = (value) => {
      if (typeof value === 'string' && value.startsWith('http')) extras.add(value);
    };
    add(data?.status_url);
    add(data?.result_url);
    add(data?.response_url);
    add(data?.video_url);
    add(data?.videoUrl);
    const urls = data?.urls;
    if (Array.isArray(urls)) urls.forEach(add);
    else if (urls && typeof urls === 'object') Object.values(urls).forEach(add);
    const queue = data?.queue;
    if (queue && typeof queue === 'object') {
      add(queue.status_url);
      add(queue.result_url);
    }
    return extras;
  }

  function normalizeOutputType(value) {
    const type = (value || '').toString().trim().toLowerCase();
    if (type === 'image' || type === 'images' || type === 'img') return 'image';
    if (type === 'audio' || type === 'sound') return 'audio';
    return 'video';
  }

  function sanitizeBase64(value) {
    if (typeof value !== 'string') return '';
    return value.replace(/^data:[^;]+;base64,/i, '').replace(/\s+/g, '');
  }

  function looksLikeBase64(value) {
    if (typeof value !== 'string') return false;
    const stripped = sanitizeBase64(value);
    return stripped.length > 32 && /^[a-z0-9+/=]+$/i.test(stripped);
  }

  function toDataUrlFromBase64(value, mime = 'application/octet-stream') {
    if (!looksLikeBase64(value)) return '';
    const stripped = sanitizeBase64(value);
    return `data:${mime};base64,${stripped}`;
  }

  function looksLikeHex(value) {
    if (typeof value !== 'string') return false;
    const trimmed = value.trim();
    return trimmed.length > 32 && trimmed.length % 2 === 0 && /^[0-9a-f]+$/i.test(trimmed);
  }

  function hexToBase64DataUrl(value, mime = 'application/octet-stream') {
    if (!looksLikeHex(value)) return '';
    const hex = value.trim();
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
      bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    const chunks = [];
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      const slice = bytes.subarray(i, i + chunkSize);
      chunks.push(String.fromCharCode.apply(null, slice));
    }
    const binary = chunks.join('');
    return `data:${mime};base64,${btoa(binary)}`;
  }

  async function openImagePopup(src) {
    const viewerUrl = new URL(chrome.runtime.getURL('viewer.html'));
    try {
      const res = await fetch(src, { referrerPolicy: 'no-referrer', credentials: 'omit' });
      if (res.ok) {
        const blob = await res.blob();
        const blobUrl = URL.createObjectURL(blob);
        viewerUrl.searchParams.set('src', blobUrl);
      } else {
        viewerUrl.searchParams.set('src', src);
      }
    } catch (err) {
      console.warn('Failed to convert image for preview', err);
      viewerUrl.searchParams.set('src', src);
    }

    const width = Math.min(window?.screen?.availWidth || 1600, 1600);
    const height = Math.min(window?.screen?.availHeight || 1000, 1000);
    try {
      await chrome.windows.create({
        url: viewerUrl.toString(),
        type: 'popup',
        focused: true,
        width,
        height,
        left: 0,
        top: 0
      });
    } catch (err) {
      console.warn('chrome.windows.create failed, fallback to window.open', err);
      window.open(viewerUrl.toString(), '_blank');
    }
  }

  function extractVideoInfo(data) {
    const logs = collectLogsFromData(data);
    const status = getStatusString(data);
    const extras = collectExtraUrls(data);

    const candidates = [];
    const pushCandidate = (value) => {
      if (!value) return;
      if (typeof value === 'string') {
        candidates.push(value);
        return;
      }
      if (typeof value === 'object') {
        const url = value.url || value.href || value.link || value.source;
        if (typeof url === 'string') candidates.push(url);
      }
    };

    pushCandidate(data?.video);
    pushCandidate(data?.video_url);
    pushCandidate(data?.videoUrl);
    pushCandidate(data?.output?.video);
    pushCandidate(data?.output?.video_url);
    pushCandidate(data?.result?.video);
    pushCandidate(data?.result?.video_url);
    pushCandidate(data?.data?.video);
    pushCandidate(data?.data?.video_url);

    const arrays = [
      data?.videos,
      data?.output?.videos,
      data?.result?.videos,
      data?.data?.videos
    ];
    arrays.forEach((arr) => {
      if (Array.isArray(arr)) arr.forEach(pushCandidate);
    });

    let videoUrl = candidates.find((url) => typeof url === 'string' && /^https?:/i.test(url)) || '';

    if (!videoUrl) {
      const fallback = new Set();
      const visit = (value, depth = 0) => {
        if (value == null || depth > 4) return;
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (/^https?:/i.test(trimmed) && /(\.mp4\b|\bvideo\b|signed_url|download)/i.test(trimmed)) fallback.add(trimmed);
          return;
        }
        if (Array.isArray(value)) {
          value.forEach((item) => visit(item, depth + 1));
          return;
        }
        if (typeof value === 'object') {
          for (const [key, val] of Object.entries(value)) {
            if (typeof val === 'string') {
              const lowerKey = key.toLowerCase();
              if (/^https?:/i.test(val) && (/(\.mp4\b|\bvideo\b|signed_url|download)/i.test(val) || lowerKey.includes('video') || lowerKey.includes('signed'))) {
                fallback.add(val);
              }
            }
            if (val && typeof val === 'object' && typeof val.url === 'string') {
              const inner = val.url.trim();
              if (/^https?:/i.test(inner) && /(\.mp4\b|\bvideo\b|signed_url|download)/i.test(inner)) fallback.add(inner);
            }
            visit(val, depth + 1);
          }
        }
      };
      visit(data);
      const fallbackUrl = Array.from(fallback).find((url) => /^https?:/i.test(url)) || '';
      if (fallbackUrl) videoUrl = fallbackUrl;
    }

    return { videoUrl, logs, status, extraUrls: Array.from(extras) };
  }

  function normalizeImageCandidate(value, index = 0) {
    if (!value) return null;
    const base = { name: `Image ${index + 1}` };
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (!trimmed) return null;
      if (/^data:image\//i.test(trimmed)) {
        return { ...base, dataUrl: trimmed, mime: trimmed.split(';')[0].split(':')[1] || '' };
      }
      if (/^https?:/i.test(trimmed)) {
        return { ...base, url: trimmed };
      }
      if (looksLikeBase64(trimmed)) {
        return { ...base, dataUrl: toDataUrlFromBase64(trimmed, 'image/png'), mime: 'image/png' };
      }
      return null;
    }
    if (typeof value === 'object') {
      const candidate = { ...base };
      const url = value.url || value.href || value.link || value.image_url || value.imageUrl || value.path || value.signed_url || value.asset_url;
      if (typeof url === 'string' && /^https?:/i.test(url)) {
        candidate.url = url;
      }
      const dataUrl = typeof value.dataUrl === 'string' ? value.dataUrl : null;
      if (dataUrl && /^data:image\//i.test(dataUrl)) candidate.dataUrl = dataUrl;
      const base64 = value.base64 || value.image_base64 || value.imageBase64 || value.b64_json || value.image;
      if (!candidate.url && !candidate.dataUrl && looksLikeBase64(base64 || '')) {
        candidate.dataUrl = toDataUrlFromBase64(base64, value.mime || value.mime_type || 'image/png');
        candidate.mime = value.mime || value.mime_type || 'image/png';
      }
      if (!candidate.url && !candidate.dataUrl && typeof value.data === 'string') {
        if (/^data:image\//i.test(value.data)) candidate.dataUrl = value.data;
        else if (looksLikeBase64(value.data)) candidate.dataUrl = toDataUrlFromBase64(value.data, value.mime || 'image/png');
      }
      if (!candidate.url && !candidate.dataUrl && typeof value.src === 'string') {
        if (/^data:image\//i.test(value.src)) candidate.dataUrl = value.src;
        else if (/^https?:/i.test(value.src)) candidate.url = value.src;
      }
      if (value.filename || value.name) candidate.filename = value.filename || value.name;
      if (candidate.url || candidate.dataUrl) return candidate;
    }
    return null;
  }

  function extractImageInfo(data) {
    const logs = collectLogsFromData(data);
    const status = getStatusString(data);
    const extras = collectExtraUrls(data);
    const images = [];
    const push = (value) => {
      if (!value) return;
      if (Array.isArray(value)) {
        value.forEach((item) => push(item));
        return;
      }
      const normalized = normalizeImageCandidate(value, images.length);
      if (normalized) images.push(normalized);
    };

    push(data?.image);
    push(data?.images);
    push(data?.output?.image);
    push(data?.output?.images);
    push(data?.result?.image);
    push(data?.result?.images);
    push(data?.data?.image);
    push(data?.data?.images);
    push(data?.output?.result);
    push(data?.artifacts);
    push(data?.output?.artifacts);
    const urls = data?.urls;
    if (Array.isArray(urls)) urls.forEach(push);

    return {
      type: 'image',
      ready: images.length > 0,
      images,
      logs,
      status,
      extraUrls: Array.from(extras)
    };
  }

  function normalizeAudioCandidate(value, index = 0) {
    if (!value) return null;
    const base = { name: `Audio ${index + 1}` };
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (!trimmed) return null;
      if (/^data:audio\//i.test(trimmed)) {
        return { ...base, dataUrl: trimmed, mime: trimmed.split(';')[0].split(':')[1] || '' };
      }
      if (/^https?:/i.test(trimmed)) {
        return { ...base, url: trimmed };
      }
      if (looksLikeBase64(trimmed)) {
        return { ...base, dataUrl: toDataUrlFromBase64(trimmed, 'audio/mpeg'), mime: 'audio/mpeg' };
      }
      if (looksLikeHex(trimmed)) {
        return { ...base, dataUrl: hexToBase64DataUrl(trimmed, 'audio/mpeg'), mime: 'audio/mpeg' };
      }
      return null;
    }
    if (typeof value === 'object') {
      const candidate = { ...base };
      const url = value.url || value.audio_url || value.audioUrl || value.href || value.link || value.path || value.signed_url;
      if (typeof url === 'string' && /^https?:/i.test(url)) candidate.url = url;
      const dataUrl = typeof value.dataUrl === 'string' ? value.dataUrl : null;
      if (dataUrl && /^data:audio\//i.test(dataUrl)) candidate.dataUrl = dataUrl;
      const base64 = value.base64 || value.b64_json || value.audio || value.data;
      if (!candidate.url && !candidate.dataUrl && looksLikeBase64(base64 || '')) {
        candidate.dataUrl = toDataUrlFromBase64(base64, value.mime || value.mime_type || 'audio/mpeg');
        candidate.mime = value.mime || value.mime_type || 'audio/mpeg';
      }
      if (!candidate.url && !candidate.dataUrl && looksLikeHex(value.hex || value.audio_hex || '')) {
        candidate.dataUrl = hexToBase64DataUrl(value.hex || value.audio_hex, value.mime || 'audio/mpeg');
        candidate.mime = value.mime || 'audio/mpeg';
      }
      if (!candidate.url && !candidate.dataUrl && typeof value.src === 'string') {
        if (/^data:audio\//i.test(value.src)) candidate.dataUrl = value.src;
        else if (/^https?:/i.test(value.src)) candidate.url = value.src;
      }
      if (value.filename || value.name) candidate.filename = value.filename || value.name;
      if (candidate.url || candidate.dataUrl) return candidate;
    }
    return null;
  }

  function extractAudioInfo(data) {
    const logs = collectLogsFromData(data);
    const status = getStatusString(data);
    const extras = collectExtraUrls(data);
    const audios = [];
    const push = (value) => {
      if (!value) return;
      if (Array.isArray(value)) {
        value.forEach((item) => push(item));
        return;
      }
      const normalized = normalizeAudioCandidate(value, audios.length);
      if (normalized) audios.push(normalized);
    };

    push(data?.audio);
    push(data?.audios);
    push(data?.output?.audio);
    push(data?.output?.audios);
    push(data?.result?.audio);
    push(data?.result?.audios);
    push(data?.data?.audio);
    push(data?.data?.audios);
    push(data?.audio_url);
    push(data?.audioUrl);
    push(data?.artifacts);
    push(data?.output?.artifacts);

    return {
      type: 'audio',
      ready: audios.length > 0,
      audios,
      logs,
      status,
      extraUrls: Array.from(extras)
    };
  }

  function extractStoryboardResult(outputType, data) {
    const type = normalizeOutputType(outputType);
    if (type === 'image') return extractImageInfo(data);
    if (type === 'audio') return extractAudioInfo(data);
    const info = extractVideoInfo(data);
    const videos = [];
    if (info.videoUrl) videos.push({ url: info.videoUrl });
    return {
      type: 'video',
      ready: videos.length > 0,
      videos,
      logs: info.logs,
      status: info.status,
      extraUrls: info.extraUrls || []
    };
  }

  function findModelByValue(value) {
    if (!value) return null;
    const [provider, ...rest] = value.split(':');
    const model = rest.join(':');
    return storyboardModels.find((entry) => entry.provider === provider && entry.model === model) || null;
  }

  function setRowOutputType(row, type) {
    const normalized = normalizeOutputType(type);
    row.state.outputType = normalized;
    if (row.state.result && row.state.result.type !== normalized) {
      row.state.result = null;
      if (row.elements.output) row.elements.output.innerHTML = '';
    }
    updateResultActions(row);
  }

  function getVideoResult(row) {
    return row?.state?.result?.type === 'video' ? row.state.result : null;
  }

  function getImageResult(row) {
    return row?.state?.result?.type === 'image' ? row.state.result : null;
  }

  function getAudioResult(row) {
    return row?.state?.result?.type === 'audio' ? row.state.result : null;
  }

  function clearResult(row) {
    row.state.result = null;
    row.state.videoControls = null;
    row.state.audioControls = null;
    if (row.elements.output) row.elements.output.innerHTML = '';
    updateResultActions(row);
  }

  function addControlEntry(row, labelText, noteText = 'Idle') {
    const list = row.elements.controlList;
    if (!list) return;
    const entry = document.createElement('div');
    entry.className = 'control-row';
    entry.setAttribute('role', 'listitem');

    const header = document.createElement('div');
    header.className = 'control-row-header';
    const label = document.createElement('span');
    label.textContent = labelText;
    const note = document.createElement('small');
    note.textContent = noteText;
    header.appendChild(label);
    header.appendChild(note);

    const titleWrap = document.createElement('div');
    titleWrap.className = 'control-title';
    const titleLabel = document.createElement('label');
    titleLabel.textContent = 'Title (optional)';
    titleLabel.setAttribute('for', `${row.id}-title`);
    const titleInput = document.createElement('input');
    titleInput.type = 'text';
    titleInput.id = `${row.id}-title`;
    titleInput.placeholder = 'Example: Evening mood';
    titleWrap.appendChild(titleLabel);
    titleWrap.appendChild(titleInput);

    const memoWrap = document.createElement('div');
    memoWrap.className = 'control-memo';
    const memoLabel = document.createElement('label');
    memoLabel.textContent = 'Memo';
    memoLabel.setAttribute('for', `${row.id}-memo`);
    const memoInput = document.createElement('input');
    memoInput.type = 'text';
    memoInput.id = `${row.id}-memo`;
    memoInput.placeholder = 'Optional notes';
    memoWrap.appendChild(memoLabel);
    memoWrap.appendChild(memoInput);

    entry.appendChild(header);
    entry.appendChild(titleWrap);
    entry.appendChild(memoWrap);

    list.appendChild(entry);
    row.elements.controlEntry = entry;
    row.elements.controlLabel = label;
    row.elements.controlNote = note;
    row.elements.controlTitle = titleInput;
    row.elements.controlMemo = memoInput;
  }

  function getRowsInDomOrder() {
    const ordered = [];
    if (!rowsContainer) return ordered;
    rowsContainer.querySelectorAll('.storyboard-row').forEach((rowEl) => {
      const rowId = rowEl.dataset.rowId;
      if (!rowId) return;
      const row = rows.get(rowId);
      if (row) ordered.push(row);
    });
    return ordered;
  }

  function reindexRows() {
    const orderedRows = getRowsInDomOrder();
    orderedRows.forEach((row, index) => {
      const sequence = index + 1;
      row.state.sequence = sequence;
      if (row.elements.controlLabel) row.elements.controlLabel.textContent = `Job ${sequence}`;
    });
  }

  function moveRow(row, direction) {
    if (!row || !rows.has(row.id)) return;
    const orderedRows = getRowsInDomOrder();
    const index = orderedRows.indexOf(row);
    if (index < 0) return;
    const targetIndex = index + direction;
    if (targetIndex < 0 || targetIndex >= orderedRows.length) return;
    const referenceRow = orderedRows[targetIndex];
    if (!referenceRow || !referenceRow.root || !row.root) return;
    if (direction < 0) {
      rowsContainer.insertBefore(row.root, referenceRow.root);
    } else {
      const nextSibling = referenceRow.root.nextSibling;
      if (nextSibling) rowsContainer.insertBefore(row.root, nextSibling);
      else rowsContainer.appendChild(row.root);
    }
    reindexRows();
    updateControlButtons();
    refreshDownloadAllState();
    highlightRow(row);
    row.root.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  function highlightRow(row) {
    if (!row || !row.root) return;
    row.root.classList.add('storyboard-row--moved');
    setTimeout(() => {
      row.root.classList.remove('storyboard-row--moved');
    }, 700);
  }

  function updateControlNote(row, text) {
    if (row?.elements?.controlNote) row.elements.controlNote.textContent = text;
  }

  function updateControlButtons() {
    const orderedRows = getRowsInDomOrder();
    const total = orderedRows.length;
    orderedRows.forEach((row, index) => {
      const addBtn = row.elements.controlAdd;
      if (addBtn) addBtn.disabled = false;
      const removeBtn = row.elements.controlRemove;
      if (removeBtn) removeBtn.disabled = !!row.state.isGenerating || total <= 1;
      const duplicateBtn = row.elements.controlDuplicate;
      if (duplicateBtn) duplicateBtn.disabled = false;
      const moveUpBtn = row.elements.controlMoveUp;
      if (moveUpBtn) moveUpBtn.disabled = index === 0;
      const moveDownBtn = row.elements.controlMoveDown;
      if (moveDownBtn) moveDownBtn.disabled = index === total - 1;
    });
  }

  function setStatus(row, message, tone = 'info', opts = {}) {
    const statusEl = row.elements.status;
    if (!statusEl) return;
    if (row.state.statusTimer) {
      clearTimeout(row.state.statusTimer);
      row.state.statusTimer = null;
    }
    statusEl.dataset.tone = tone || 'info';
    statusEl.textContent = message || '';
    if (!message) {
      statusEl.classList.remove('is-visible');
      return;
    }
    statusEl.classList.add('is-visible');
    if (opts?.duration) {
      row.state.statusTimer = setTimeout(() => {
        statusEl.classList.remove('is-visible');
        statusEl.textContent = '';
        row.state.statusTimer = null;
      }, opts.duration);
    }
  }

  function setBusy(row, flag) {
    row.state.isGenerating = !!flag;
    const generateBtn = row.elements.generateBtn;
    const cancelBtn = row.elements.cancelBtn;
    if (generateBtn) {
      generateBtn.disabled = flag;
      generateBtn.textContent = flag ? 'Generating...' : 'Generate';
    }
    if (cancelBtn) cancelBtn.disabled = !flag;
    const addBtn = row.elements.controlAdd;
    if (addBtn) addBtn.disabled = false;
    const removeBtn = row.elements.controlRemove;
    if (removeBtn) removeBtn.disabled = flag || rows.size <= 1;
    const duplicateBtn = row.elements.controlDuplicate;
    if (duplicateBtn) duplicateBtn.disabled = false;
    updateControlButtons();
  }

  function updateResultActions(row) {
    refreshDownloadAllState();
  }

  function showLogs(row, lines) {
    const wrapper = row.elements.logsWrapper;
    const body = row.elements.logsBody;
    if (!wrapper || !body) return;
    if (!lines || !lines.length) {
      wrapper.hidden = true;
      body.textContent = '';
      return;
    }
    wrapper.hidden = false;
    body.textContent = lines.join('\n');
  }

  function renderVideo(row, url, meta = {}) {
    const outputEl = row.elements.output;
    if (!outputEl) return;
    row.state.result = {
      type: 'video',
      videos: url ? [{ url, meta }] : [],
      meta
    };
    row.state.videoControls = null;
    outputEl.innerHTML = '';
    if (!url) {
      updateResultActions(row);
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'video-result';

    const media = document.createElement('div');
    media.className = 'video-result-media';
    const video = document.createElement('video');
    video.controls = true;
    video.playsInline = true;
    video.preload = 'metadata';
    video.src = url;
    video.setAttribute('controlsList', 'nodownload');
    video.className = 'video';
    media.appendChild(video);

    const controls = document.createElement('div');
    controls.className = 'video-result-controls';

    if (meta?.modelLabel) {
      const badge = document.createElement('span');
      badge.className = 'video-badge video-result-badge';
      badge.textContent = meta.modelLabel;
      controls.appendChild(badge);
    }

    const downloadBtn = document.createElement('button');
    downloadBtn.type = 'button';
    downloadBtn.textContent = 'Download Video';
    downloadBtn.addEventListener('click', () => handleDownload(row));
    controls.appendChild(downloadBtn);

    const stepper = document.createElement('div');
    stepper.className = 'video-stepper';

    const stepBackBtn = document.createElement('button');
    stepBackBtn.type = 'button';
    stepBackBtn.textContent = '◀︎ 1F';
    stepBackBtn.addEventListener('click', () => stepFrame(row, -1));
    stepper.appendChild(stepBackBtn);

    const stepResetBtn = document.createElement('button');
    stepResetBtn.type = 'button';
    stepResetBtn.textContent = 'Reset';
    stepResetBtn.addEventListener('click', () => resetFrame(row));
    stepper.appendChild(stepResetBtn);

    const stepForwardBtn = document.createElement('button');
    stepForwardBtn.type = 'button';
    stepForwardBtn.textContent = '1F ▶︎';
    stepForwardBtn.addEventListener('click', () => stepFrame(row, 1));
    stepper.appendChild(stepForwardBtn);

    controls.appendChild(stepper);

    const copyBtn = document.createElement('button');
    copyBtn.type = 'button';
    copyBtn.textContent = 'Copy Frame to Clipboard';
    copyBtn.addEventListener('click', () => handleCopy(row));
    controls.appendChild(copyBtn);

    const footer = document.createElement('div');
    footer.className = 'video-footer';
    const link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    link.textContent = 'Open video in new tab';
    footer.appendChild(link);
    controls.appendChild(footer);

    wrapper.appendChild(media);
    wrapper.appendChild(controls);

    outputEl.appendChild(wrapper);

    row.state.videoControls = {
      downloadBtn,
      copyBtn,
      stepBackBtn,
      stepForwardBtn,
      stepResetBtn
    };

    const hasVideo = !!url;
    downloadBtn.disabled = !hasVideo;
    copyBtn.disabled = !hasVideo;
    stepBackBtn.disabled = !hasVideo;
    stepForwardBtn.disabled = !hasVideo;
    stepResetBtn.disabled = !hasVideo;

    updateResultActions(row);
    setupStepper(row, video);
  }

  function renderImages(row, info, meta = {}) {
    const outputEl = row.elements.output;
    if (!outputEl) return;
    const rawImages = Array.isArray(info?.images) ? info.images : [];
    const normalized = rawImages.map((item, index) => {
      const src = item?.dataUrl || item?.url || item?.src || '';
      const name = item?.name || item?.filename || `Image ${index + 1}`;
      const mime = item?.mime || (src.startsWith('data:image/') ? src.split(';')[0].split(':')[1] : '');
      return { ...item, src, name, mime };
    }).filter((item) => item.src);

    row.state.result = {
      type: 'image',
      images: normalized,
      meta
    };

    outputEl.innerHTML = '';
    if (!normalized.length) {
      updateResultActions(row);
      return;
    }

    const list = document.createElement('div');
    list.className = 'image-results';
    normalized.forEach((item, index) => {
      const block = document.createElement('div');
      block.className = 'image-result';

      const preview = document.createElement('div');
      preview.className = 'image-result-preview';
      preview.tabIndex = 0;
      const img = document.createElement('img');
      img.src = item.src;
      img.alt = item.name || `Image ${index + 1}`;
      preview.appendChild(img);
      const handlePreview = () => openImagePreview(row, index);
      preview.addEventListener('click', handlePreview);
      preview.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          handlePreview();
        }
      });

      const info = document.createElement('div');
      info.className = 'image-result-info';
      const title = document.createElement('div');
      title.className = 'image-result-title';
      title.textContent = item.name || `Image ${index + 1}`;
      info.appendChild(title);

      const actions = document.createElement('div');
      actions.className = 'image-result-actions';

      const previewBtn = document.createElement('button');
      previewBtn.type = 'button';
      previewBtn.textContent = 'Preview';
      previewBtn.addEventListener('click', handlePreview);
      actions.appendChild(previewBtn);

      const downloadBtn = document.createElement('button');
      downloadBtn.type = 'button';
      downloadBtn.textContent = 'Download';
      downloadBtn.addEventListener('click', () => handleDownloadImage(row, index, downloadBtn));
      actions.appendChild(downloadBtn);

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.textContent = 'Copy';
      copyBtn.addEventListener('click', () => handleCopyImage(row, index, copyBtn));
      actions.appendChild(copyBtn);

      info.appendChild(actions);

      block.appendChild(preview);
      block.appendChild(info);
      list.appendChild(block);
    });

    outputEl.appendChild(list);
    updateResultActions(row);
  }

  function renderAudio(row, info, meta = {}) {
    const outputEl = row.elements.output;
    if (!outputEl) return;
    const rawAudios = Array.isArray(info?.audios) ? info.audios : [];
    const normalized = rawAudios.map((item, index) => {
      const src = item?.dataUrl || item?.url || item?.src || '';
      const name = item?.name || item?.filename || `Audio ${index + 1}`;
      const mime = item?.mime || (src.startsWith('data:audio/') ? src.split(';')[0].split(':')[1] : '');
      return { ...item, src, name, mime };
    }).filter((item) => item.src);

    row.state.result = {
      type: 'audio',
      audios: normalized,
      meta
    };

    outputEl.innerHTML = '';
    if (!normalized.length) {
      updateResultActions(row);
      return;
    }

    const list = document.createElement('div');
    list.className = 'audio-results';

    normalized.forEach((item, index) => {
      const block = document.createElement('div');
      block.className = 'audio-result';

      const playerWrap = document.createElement('div');
      playerWrap.className = 'audio-result-player';
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.preload = 'metadata';
      audio.src = item.src;
      audio.setAttribute('controlsList', 'nodownload');
      playerWrap.appendChild(audio);

      const info = document.createElement('div');
      info.className = 'audio-result-info';
      const title = document.createElement('div');
      title.className = 'audio-result-title';
      title.textContent = item.name || `Audio ${index + 1}`;
      info.appendChild(title);

      if (meta?.modelLabel && index === 0) {
        const badge = document.createElement('span');
        badge.className = 'video-badge audio-result-badge';
        badge.textContent = meta.modelLabel;
        info.appendChild(badge);
      }

      const actions = document.createElement('div');
      actions.className = 'audio-result-actions';
      const downloadBtn = document.createElement('button');
      downloadBtn.type = 'button';
      downloadBtn.textContent = 'Download Audio';
      downloadBtn.addEventListener('click', () => handleDownloadAudio(row, index, downloadBtn));
      actions.appendChild(downloadBtn);
      info.appendChild(actions);

      block.appendChild(playerWrap);
      block.appendChild(info);
      list.appendChild(block);
    });

    outputEl.appendChild(list);
    updateResultActions(row);
  }

  function ensureRowVideoState(row) {
    if (!row.state.video) row.state.video = { frameDuration: 1 / 30, lastTimestamp: 0 };
    return row.state.video;
  }

  function setupStepper(row, video) {
    const state = ensureRowVideoState(row);
    state.videoElement = video;
    state.originalTime = 0;
    state.frameDuration = 1 / 30;
    state.ready = false;

    const estimateFrame = ({ presentationTime }, metadata) => {
      const last = state.lastTimestamp || presentationTime;
      const delta = presentationTime - last;
      if (delta > 0 && delta < 1) {
        state.frameDuration = delta;
      }
      state.lastTimestamp = presentationTime;
      if (!state.ready && presentationTime >= 0) {
        state.originalTime = presentationTime;
        state.ready = true;
      }
      if (!video.paused && video.currentTime < video.duration) {
        video.requestVideoFrameCallback(estimateFrame);
      }
    };

    const onLoadedMetadata = () => {
      state.originalTime = video.currentTime;
      state.ready = true;
      video.requestVideoFrameCallback(estimateFrame);
    };

    video.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
    if (video.readyState >= 1) onLoadedMetadata();
  }

  async function copyFrameToClipboard(row) {
    if (!navigator?.clipboard?.write || typeof ClipboardItem === 'undefined') {
      throw new Error('クリップボードに画像をコピーできません。ブラウザの対応状況を確認してください。');
    }
    const video = row.elements.output?.querySelector('video');
    if (!video) throw new Error('コピーできる動画がありません。');
    if (video.readyState < 2) {
      await new Promise((resolve, reject) => {
        const onLoad = () => { cleanup(); resolve(); };
        const onError = () => { cleanup(); reject(new Error('動画の読み込みに失敗しました。')); };
        const cleanup = () => {
          video.removeEventListener('loadeddata', onLoad);
          video.removeEventListener('error', onError);
        };
        video.addEventListener('loadeddata', onLoad, { once: true });
        video.addEventListener('error', onError, { once: true });
      });
    }
    const width = video.videoWidth;
    const height = video.videoHeight;
    if (!width || !height) throw new Error('動画サイズを取得できませんでした。');
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas コンテキストの作成に失敗しました。');
    try {
      ctx.drawImage(video, 0, 0, width, height);
    } catch (err) {
      throw new Error('動画のフレームを取得できませんでした。（クロスオリジン制限の可能性があります）');
    }
    const blob = await new Promise((resolve, reject) => {
      canvas.toBlob((b) => (b ? resolve(b) : reject(new Error('フレーム画像の生成に失敗しました。'))), 'image/png');
    });
    const item = new ClipboardItem({ 'image/png': blob });
    await navigator.clipboard.write([item]);
  }

  function isImageLikeFile(file) {
    if (!file) return false;
    const mime = (file.type || '').toLowerCase();
    if (mime.startsWith('image/')) return true;
    const name = (file.name || '').toLowerCase();
    return /\.(png|jpe?g|gif|webp|bmp|heic|heif|tif?f|svg)$/.test(name);
  }

  const IMAGE_SIZE_LIMIT_BYTES = 1.6 * 1024 * 1024;
  const IMAGE_DATAURL_LIMIT = 2.4 * 1024 * 1024;
  const IMAGE_MAX_DIMENSION = 1280;

  function readFileAsDataUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          if (typeof reader.result !== 'string') {
            reject(new Error('画像データの読み込みに失敗しました。'));
            return;
          }
          const optimized = await optimizeImageDataUrl(file, reader.result);
          resolve(optimized);
        } catch (err) {
          reject(err);
        }
      };
      reader.onerror = () => reject(new Error('画像データの読み込みに失敗しました。'));
      reader.readAsDataURL(file);
    });
  }

  async function optimizeImageDataUrl(file, dataUrl) {
    if (!dataUrl) return dataUrl;
    if ((file?.size || 0) <= IMAGE_SIZE_LIMIT_BYTES && dataUrl.length <= IMAGE_DATAURL_LIMIT) {
      return dataUrl;
    }
    try {
      const recompressed = await recompressImageDataUrl(dataUrl, {
        maxDimension: IMAGE_MAX_DIMENSION,
        lengthLimit: IMAGE_DATAURL_LIMIT
      });
      if (recompressed && recompressed.length < dataUrl.length) return recompressed;
    } catch (err) {
      console.warn('Failed to recompress image', err);
    }
    return dataUrl;
  }

  function loadImageFromDataUrl(dataUrl) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('画像の読み込みに失敗しました。'));
      img.src = dataUrl;
    });
  }

  async function recompressImageDataUrl(dataUrl, options = {}) {
    const { maxDimension = 1280, lengthLimit = Infinity } = options;
    const img = await loadImageFromDataUrl(dataUrl);
    const width = img.width || 1;
    const height = img.height || 1;
    const longest = Math.max(width, height) || 1;
    const scale = longest > maxDimension ? maxDimension / longest : 1;
    const targetWidth = Math.max(1, Math.round(width * scale));
    const targetHeight = Math.max(1, Math.round(height * scale));

    const canvas = document.createElement('canvas');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas コンテキストを取得できませんでした。');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, targetWidth, targetHeight);
    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);

    const qualities = [0.88, 0.8, 0.72, 0.66, 0.6, 0.55];
    let best = '';
    for (const quality of qualities) {
      const candidate = canvas.toDataURL('image/jpeg', quality);
      best = candidate;
      if (candidate.length <= lengthLimit) break;
    }
    return best;
  }

  function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (typeof reader.result === 'string') resolve(reader.result);
        else reject(new Error('画像データの読み込みに失敗しました。'));
      };
      reader.onerror = () => reject(new Error('画像データの読み込みに失敗しました。'));
      reader.readAsDataURL(blob);
    });
  }

  async function readClipboardImages() {
    if (!navigator?.clipboard) {
      throw new Error('クリップボードへアクセスできません。ブラウザの設定を確認してください。');
    }
    if (typeof navigator.clipboard.read !== 'function') {
      throw new Error('クリップボードから画像を取得できません。ブラウザが対応していません。');
    }
    let items;
    try {
      items = await navigator.clipboard.read();
    } catch (err) {
      const message = err?.name === 'NotAllowedError'
        ? 'クリップボードへのアクセスが許可されていません。ブラウザの設定を確認してください。'
        : 'クリップボードから画像を読み取れませんでした。';
      throw new Error(message);
    }
    const results = [];
    for (const item of items || []) {
      if (!item?.types) continue;
      for (const type of item.types) {
        if (!type || !type.toLowerCase().startsWith('image/')) continue;
        let blob;
        try {
          blob = await item.getType(type);
        } catch (err) {
          console.warn('Failed to access clipboard item', err);
          continue;
        }
        if (!blob) continue;
        try {
          const dataUrl = await blobToDataUrl(blob);
          const optimized = await optimizeImageDataUrl({ size: blob.size }, dataUrl);
          results.push({
            dataUrl: optimized,
            name: `Clipboard Image ${results.length + 1}`
          });
        } catch (err) {
          console.warn('Failed to process clipboard image', err);
        }
      }
    }
    return results;
  }

  function joinFieldKey(parent, key) {
    if (!key) return parent || '';
    return parent ? `${parent}.${key}` : key;
  }

  function assignNestedValue(target, path, value) {
    if (!path) return;
    const segments = path.split('.');
    let cursor = target;
    for (let i = 0; i < segments.length - 1; i++) {
      const segment = segments[i];
      if (!Object.prototype.hasOwnProperty.call(cursor, segment) || typeof cursor[segment] !== 'object' || cursor[segment] === null) {
        cursor[segment] = {};
      }
      cursor = cursor[segment];
    }
    cursor[segments[segments.length - 1]] = value;
  }

  function getNestedValue(source, path) {
    if (!path) return undefined;
    const segments = path.split('.');
    let cursor = source;
    for (const segment of segments) {
      if (cursor === null || cursor === undefined) return undefined;
      if (typeof cursor !== 'object') return undefined;
      cursor = cursor[segment];
    }
    return cursor;
  }

  function ensureHiddenStore(row) {
    if (!row?.state) return {};
    if (!row.state.hiddenValues || typeof row.state.hiddenValues !== 'object') {
      row.state.hiddenValues = {};
    }
    if (!(row.state.hiddenFieldKeys instanceof Set)) {
      row.state.hiddenFieldKeys = new Set();
    }
    return row.state.hiddenValues;
  }

  function resolveHiddenDefault(def, baseType) {
    if (!def) return undefined;
    if (baseType === 'select') {
      const options = Array.isArray(def.options) ? def.options : [];
      const chosen = options.find((opt) => opt?.default) || options[0];
      if (chosen && chosen.value !== undefined) return String(chosen.value);
      if (def.default !== undefined && def.default !== null) return String(def.default);
      if (chosen && chosen.label !== undefined) return String(chosen.label);
      return undefined;
    }
    if (baseType === 'boolean') {
      if (typeof def.default === 'boolean') return def.default;
      if (typeof def.default === 'string') return def.default === 'true';
      if (typeof def.default === 'number') return def.default !== 0;
      return undefined;
    }
    if (baseType === 'number') {
      if (def.default !== undefined && def.default !== null) {
        const num = Number(def.default);
        return Number.isNaN(num) ? undefined : num;
      }
      const options = Array.isArray(def.options) ? def.options : [];
      const chosen = options.find((opt) => opt?.default) || options[0];
      if (chosen && chosen.value !== undefined) {
        const num = Number(chosen.value);
        return Number.isNaN(num) ? undefined : num;
      }
      return undefined;
    }
    if (baseType === 'singleimage' || baseType === 'multiimages' || baseType === 'multiimage') {
      return undefined;
    }
    if (def.default !== undefined && def.default !== null) {
      return String(def.default);
    }
    return undefined;
  }

  function collectHiddenDefaults(row, def, parentKey = '', forceHidden = false) {
    if (!def || typeof def !== 'object') return;
    const key = def.key || def.type || '';
    const rawType = (def.type || 'text').toLowerCase();
    const baseType = rawType.replace(/[-_\s]/g, '');
    const keyPath = joinFieldKey(parentKey, key);
    const isContainer = rawType === 'container';
    const hidden = forceHidden || def.hidden === true;

    if (isContainer) {
      const children = Array.isArray(def.contents) ? def.contents : [];
      children.forEach((child) => collectHiddenDefaults(row, child, keyPath, hidden));
    }

    if (!hidden || !keyPath || isContainer) return;

    const store = ensureHiddenStore(row);
    row.state.hiddenFieldKeys.add(keyPath);
    const value = resolveHiddenDefault(def, baseType);
    if (value !== undefined) {
      assignNestedValue(store, keyPath, value);
    }
  }

  function mergeHiddenDefaults(target, source) {
    if (!source || typeof source !== 'object') return;
    Object.entries(source).forEach(([key, value]) => {
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        if (!Object.prototype.hasOwnProperty.call(target, key) || typeof target[key] !== 'object' || target[key] === null || Array.isArray(target[key])) {
          target[key] = {};
        }
        mergeHiddenDefaults(target[key], value);
        return;
      }
      if (!Object.prototype.hasOwnProperty.call(target, key)) {
        target[key] = value;
      }
    });
  }

  function flattenFieldDefs(defs, parentKey = '') {
    const result = [];
    (defs || []).forEach((def) => {
      if (!def || typeof def !== 'object') return;
      const key = def.key || def.type || '';
      const keyPath = key ? joinFieldKey(parentKey, key) : parentKey;
      const rawType = (def.type || '').toLowerCase();
      const isContainer = rawType === 'container';
      result.push({ key: keyPath, def, container: isContainer });
      if (isContainer) {
        const children = flattenFieldDefs(Array.isArray(def.contents) ? def.contents : [], keyPath);
        result.push(...children);
      }
    });
    return result;
  }

  function createImageField(row, def, mode, parentKey = '') {
    const key = def.key || def.type || 'image';
    const keyPath = joinFieldKey(parentKey, key);
    const limit = typeof def.max === 'number' && def.max > 0 ? def.max : null;
    const wrapper = document.createElement('div');
    wrapper.className = 'toolbar-field toolbar-field--upload';

    const label = document.createElement('label');
    label.textContent = def.label || key;
    wrapper.appendChild(label);

    const dropzone = document.createElement('div');
    dropzone.className = 'image-dropzone';
    dropzone.tabIndex = 0;
    dropzone.dataset.fieldKey = keyPath;
    dropzone.dataset.fieldType = mode === 'multi' ? 'multiimages' : 'singleimage';
    dropzone.dataset.fieldLabel = def.label || key;
    if (def.optional) dropzone.dataset.optional = '1';
    if (limit) dropzone.dataset.maxCount = String(limit);

    const instructions = document.createElement('div');
    instructions.className = 'image-dropzone-instructions';
    instructions.textContent = mode === 'multi'
      ? `Drag & drop ${limit ? `up to ${limit} images` : 'images'}, or click to choose.`
      : 'Drag & drop an image, or click to choose.';
    dropzone.appendChild(instructions);

    const hint = document.createElement('div');
    hint.className = 'image-dropzone-hint';
    hint.textContent = 'Accepted formats: PNG, JPG, GIF, WebP.';
    dropzone.appendChild(hint);

    const actions = document.createElement('div');
    actions.className = 'image-dropzone-actions';
    const pasteButton = document.createElement('button');
    pasteButton.type = 'button';
    pasteButton.className = 'image-clipboard';
    pasteButton.innerHTML = '<span>クリップボードの画像を貼り付け</span>';
    if (typeof navigator?.clipboard?.read !== 'function') {
      pasteButton.disabled = true;
      pasteButton.title = 'ブラウザが画像の貼り付けに対応していません。';
    }
    actions.appendChild(pasteButton);
    dropzone.appendChild(actions);

    const previews = document.createElement('div');
    previews.className = 'image-previews';
    dropzone.appendChild(previews);

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.multiple = mode === 'multi';
    fileInput.hidden = true;
    dropzone.appendChild(fileInput);

    wrapper.appendChild(dropzone);

    const normalizeSingle = (value) => {
      if (!value) return null;
      if (typeof value === 'string') return { dataUrl: value, name: def.label || key };
      if (value?.dataUrl) {
        return {
          dataUrl: value.dataUrl,
          name: value.name || value.filename || def.label || key
        };
      }
      return null;
    };

    const normalizeMulti = (value) => {
      const list = Array.isArray(value) ? value : [];
      const items = [];
      list.forEach((entry, index) => {
        if (!entry) return;
        if (typeof entry === 'string') {
          items.push({ dataUrl: entry, name: `Image ${index + 1}` });
          return;
        }
        if (entry.dataUrl) {
          items.push({
            dataUrl: entry.dataUrl,
            name: entry.name || entry.filename || `Image ${index + 1}`
          });
        }
      });
      return items;
    };

    const setValue = (value) => {
      if (mode === 'multi') {
        dropzone.storyValue = normalizeMulti(value);
      } else {
        dropzone.storyValue = normalizeSingle(value);
      }
      updatePreview();
    };

    const updatePreview = () => {
      previews.innerHTML = '';
      if (mode === 'multi') {
        const items = Array.isArray(dropzone.storyValue) ? dropzone.storyValue : [];
        dropzone.classList.toggle('has-value', items.length > 0);
        items.forEach((item, index) => {
          if (!item?.dataUrl) return;
          const preview = document.createElement('div');
          preview.className = 'image-preview';
          const thumb = document.createElement('img');
          thumb.src = item.dataUrl;
          thumb.alt = item.name || `Image ${index + 1}`;
          preview.appendChild(thumb);
          const footer = document.createElement('div');
          footer.className = 'image-preview-footer';
          const nameEl = document.createElement('span');
          nameEl.textContent = item.name || `Image ${index + 1}`;
          footer.appendChild(nameEl);
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'image-remove';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            const next = Array.isArray(dropzone.storyValue) ? dropzone.storyValue.slice() : [];
            next.splice(index, 1);
            dropzone.storyValue = next;
            updatePreview();
          });
          footer.appendChild(removeBtn);
          preview.appendChild(footer);
          previews.appendChild(preview);
        });
      } else {
        const item = dropzone.storyValue && dropzone.storyValue.dataUrl ? dropzone.storyValue : null;
        dropzone.classList.toggle('has-value', !!item);
        if (item) {
          const preview = document.createElement('div');
          preview.className = 'image-preview';
          const thumb = document.createElement('img');
          thumb.src = item.dataUrl;
          thumb.alt = item.name || 'Selected image';
          preview.appendChild(thumb);
          const footer = document.createElement('div');
          footer.className = 'image-preview-footer';
          const nameEl = document.createElement('span');
          nameEl.textContent = item.name || 'Selected image';
          footer.appendChild(nameEl);
          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.className = 'image-remove';
          removeBtn.textContent = 'Remove';
          removeBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropzone.storyValue = null;
            updatePreview();
          });
          footer.appendChild(removeBtn);
          preview.appendChild(footer);
          previews.appendChild(preview);
        }
      }
    };

    const handleFiles = async (fileList) => {
      const files = Array.from(fileList || []).filter(isImageLikeFile);
      if (!files.length) {
        setStatus(row, '画像ファイルを選択してください。', 'error', { duration: 2000 });
        return;
      }

      if (mode === 'single') {
        const file = files[0];
        try {
          const dataUrl = await readFileAsDataUrl(file);
          setValue({ dataUrl, name: file.name || file.type || 'Image' });
        } catch (err) {
          console.error('Failed to read image', err);
          setStatus(row, '画像の読み込みに失敗しました。', 'error', { duration: 2200 });
        }
        return;
      }

      const current = Array.isArray(dropzone.storyValue) ? dropzone.storyValue.slice() : [];
      const limitRemaining = limit ? Math.max(0, limit - current.length) : files.length;
      if (limit && limitRemaining <= 0) {
        setStatus(row, `画像は最大${limit}枚までです。`, 'error', { duration: 2200 });
        return;
      }

      const usable = limit ? files.slice(0, limitRemaining) : files;
      const additions = [];
      for (const file of usable) {
        try {
          const dataUrl = await readFileAsDataUrl(file);
          additions.push({ dataUrl, name: file.name || `Image ${current.length + additions.length + 1}` });
        } catch (err) {
          console.error('Failed to read image', err);
          setStatus(row, `画像「${file.name || 'unknown'}」の読み込みに失敗しました。`, 'error', { duration: 2200 });
        }
      }
      setValue(current.concat(additions));
      if (limit && files.length > usable.length) {
        setStatus(row, `画像は最大${limit}枚までです。`, 'error', { duration: 2200 });
      }
    };

    const applyClipboardImages = (images) => {
      if (!Array.isArray(images) || !images.length) {
        setStatus(row, 'クリップボードに画像が見つかりません。', 'error', { duration: 2000 });
        return false;
      }
      if (mode === 'single') {
        setValue(images[0]);
        return true;
      }
      const current = Array.isArray(dropzone.storyValue) ? dropzone.storyValue.slice() : [];
      const limitRemaining = limit ? Math.max(0, limit - current.length) : images.length;
      if (limit && limitRemaining <= 0) {
        setStatus(row, `画像は最大${limit}枚までです。`, 'error', { duration: 2200 });
        return false;
      }
      const additions = images.slice(0, limitRemaining).map((item, index) => ({
        dataUrl: item.dataUrl,
        name: item.name || `Clipboard ${current.length + index + 1}`
      }));
      if (!additions.length) return false;
      setValue(current.concat(additions));
      if (limit && images.length > limitRemaining) {
        setStatus(row, `画像は最大${limit}枚までです。`, 'error', { duration: 2200 });
      }
      return true;
    };

    const handleClipboardPaste = async () => {
      if (pasteButton.disabled) return;
      if (typeof navigator?.clipboard?.read !== 'function') {
        setStatus(row, 'クリップボードから画像を取得できません。ブラウザが対応していません。', 'error', { duration: 2600 });
        return;
      }
      pasteButton.disabled = true;
      dropzone.classList.add('is-loading');
      try {
        setStatus(row, 'クリップボードから画像を取得しています...', 'info');
        const images = await readClipboardImages();
        const applied = applyClipboardImages(images);
        if (applied) {
          setStatus(row, 'クリップボードから画像を貼り付けました。', 'success', { duration: 2000 });
        }
      } catch (err) {
        console.error('Failed to read clipboard image', err);
        const message = err?.message || 'クリップボードからの貼り付けに失敗しました。';
        setStatus(row, message, 'error', { duration: 2600 });
      } finally {
        dropzone.classList.remove('is-loading');
        pasteButton.disabled = typeof navigator?.clipboard?.read !== 'function';
      }
    };

    dropzone.storyValue = mode === 'multi' ? [] : null;
    dropzone.storySetValue = setValue;
    dropzone.storyGetValue = () => dropzone.storyValue;

    dropzone.addEventListener('dragenter', (event) => {
      event.preventDefault();
      dropzone.classList.add('is-dragover');
    });
    dropzone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropzone.classList.add('is-dragover');
    });
    dropzone.addEventListener('dragleave', (event) => {
      if (!dropzone.contains(event.relatedTarget)) {
        dropzone.classList.remove('is-dragover');
      }
    });
    dropzone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropzone.classList.remove('is-dragover');
      const files = event.dataTransfer?.files;
      if (files?.length) handleFiles(files);
    });
    dropzone.addEventListener('click', (event) => {
      if (event.target.closest('.image-remove') || event.target.closest('.image-clipboard')) return;
      fileInput.click();
    });
    dropzone.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        if (event.target.closest('.image-clipboard')) {
          handleClipboardPaste();
        } else {
          fileInput.click();
        }
      }
    });
    fileInput.addEventListener('change', () => {
      if (fileInput.files?.length) handleFiles(fileInput.files);
      fileInput.value = '';
    });
    pasteButton.addEventListener('click', (event) => {
      event.preventDefault();
      event.stopPropagation();
      handleClipboardPaste();
    });

    return wrapper;
  }

  function createFieldElement(row, def, parentKey = '') {
    const key = def.key || def.type || 'field';
    const rawType = (def.type || 'text').toLowerCase();
    const baseType = rawType.replace(/[-_\s]/g, '');
    const keyPath = joinFieldKey(parentKey, key);
    if (def.hidden) {
      return null;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'toolbar-field';

    if (baseType === 'singleimage') {
      return createImageField(row, def, 'single', parentKey);
    }
    if (baseType === 'multiimages' || baseType === 'multiimage') {
      return createImageField(row, def, 'multi', parentKey);
    }

    if (rawType === 'container') {
      wrapper.classList.add('toolbar-field--group');
      if (def.label) {
        const title = document.createElement('div');
        title.className = 'toolbar-group-title';
        title.textContent = def.label;
        wrapper.appendChild(title);
      }
      const group = document.createElement('div');
      group.className = 'toolbar-group-fields';
      const contents = Array.isArray(def.contents) ? def.contents : [];
      contents.forEach((childDef) => {
        try {
          const childEl = createFieldElement(row, childDef, keyPath);
          if (childEl) group.appendChild(childEl);
        } catch (err) {
          console.error('Failed to render nested storyboard field', childDef, err);
        }
      });
      wrapper.appendChild(group);
      return wrapper;
    }

    const labelText = def.label || key;

    if (rawType === 'boolean') {
      wrapper.classList.add('toolbar-field--toggle');
      const toggle = document.createElement('label');
      toggle.className = 'toggle';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.dataset.fieldKey = keyPath;
      input.dataset.fieldType = rawType;
      input.dataset.fieldLabel = labelText;
      if (def.optional) input.dataset.optional = '1';
      if (def.default === true) input.checked = true;
      const slider = document.createElement('span');
      slider.className = 'toggle-slider';
      slider.setAttribute('aria-hidden', 'true');
      const text = document.createElement('span');
      text.className = 'toggle-text';
      text.textContent = labelText;
      toggle.appendChild(input);
      toggle.appendChild(text);
      toggle.appendChild(slider);
      wrapper.appendChild(toggle);
      return wrapper;
    }

    const label = document.createElement('label');
    const textSpan = document.createElement('span');
    textSpan.className = 'toolbar-field-text';
    textSpan.textContent = labelText;

    let input;
    if (rawType === 'select') {
      input = document.createElement('select');
      const options = Array.isArray(def.options) ? def.options : [];
      let anySelected = false;
      for (const opt of options) {
        const optionEl = document.createElement('option');
        optionEl.value = opt?.value !== undefined ? String(opt.value) : '';
        optionEl.textContent = opt?.label ?? optionEl.value;
        if (opt?.default && !anySelected) {
          optionEl.selected = true;
          anySelected = true;
        }
        input.appendChild(optionEl);
      }
      if (!anySelected && def.default !== undefined) input.value = String(def.default);
    } else if (rawType === 'textarea' || def.multiline || key === 'prompt') {
      input = document.createElement('textarea');
      input.rows = def.rows || 1;
      input.maxLength = def.maxLength || 2000;
      if (def.default !== undefined && def.default !== null) input.value = String(def.default);
    } else {
      input = document.createElement('input');
      input.type = rawType === 'number' ? 'number' : 'text';
      if (rawType === 'number') {
        if (typeof def.min === 'number') input.min = String(def.min);
        if (typeof def.max === 'number') input.max = String(def.max);
        if (typeof def.step === 'number') input.step = String(def.step);
      }
      if (def.default !== undefined && def.default !== null) input.value = String(def.default);
    }

    if (def.placeholder && input) input.placeholder = def.placeholder;
    if (def.required && input) input.required = true;

    input.dataset.fieldKey = keyPath;
    input.dataset.fieldType = rawType;
    input.dataset.fieldLabel = labelText;
    if (def.optional) input.dataset.optional = '1';
    label.appendChild(textSpan);
    label.appendChild(input);
    wrapper.appendChild(label);
    return wrapper;
  }

  function renderFields(row) {
    const container = row.elements.fieldsContainer;
    if (!container) return;
    container.innerHTML = '';
    row.state.missingFields = [];
    row.state.hiddenValues = {};
    row.state.hiddenFieldKeys = new Set();
    if (!storyboardModels.length) return;
    const select = row.elements.modelSelect;
    const entry = findModelByValue(select?.value || '');
    setRowOutputType(row, entry?.output || 'video');
    const fields = Array.isArray(entry?.inputs)
      ? entry.inputs
      : Array.isArray(entry?.prompt)
        ? entry.prompt
        : [];
    fields.forEach((def) => {
      try {
        collectHiddenDefaults(row, def, '');
        const fieldEl = createFieldElement(row, def, '');
        if (fieldEl) container.appendChild(fieldEl);
      } catch (err) {
        console.error('Failed to render storyboard field', def, err);
      }
    });
  }

  function collectParameters(row) {
    const container = row.elements.fieldsContainer;
    const params = {};
    const missing = [];
    if (!container) {
      row.state.missingFields = [];
      return params;
    }
    container.querySelectorAll('[data-field-key]').forEach((el) => {
      const keyPath = el.dataset.fieldKey;
      if (!keyPath) return;
      const type = (el.dataset.fieldType || '').toLowerCase();
      const label = el.dataset.fieldLabel || keyPath;
      const optional = el.dataset.optional === '1';

      if (type === 'container') {
        return;
      }

      if (type === 'boolean') {
        assignNestedValue(params, keyPath, !!el.checked);
        return;
      }

      if (type === 'singleimage' || type === 'singleimages') {
        const value = typeof el.storyGetValue === 'function' ? el.storyGetValue() : el.storyValue;
        const dataUrl = value?.dataUrl || (typeof value === 'string' ? value : '');
        if (dataUrl) assignNestedValue(params, keyPath, dataUrl);
        else if (!optional) missing.push(label);
        return;
      }

      if (type === 'multiimages' || type === 'multiimage') {
        const raw = typeof el.storyGetValue === 'function' ? el.storyGetValue() : el.storyValue;
        const list = Array.isArray(raw) ? raw : [];
        const data = list
          .map((item) => {
            if (!item) return '';
            if (typeof item === 'string') return item;
            if (item.dataUrl) return item.dataUrl;
            return '';
          })
          .filter(Boolean);
        if (data.length) assignNestedValue(params, keyPath, data);
        else if (!optional) missing.push(label);
        return;
      }

      if (type === 'number') {
        const value = el.value;
        if (value === '' || value === null || Number.isNaN(Number(value))) {
          if (!optional && el.required) missing.push(label);
          return;
        }
        assignNestedValue(params, keyPath, Number(value));
        return;
      }

      const value = (el.value || '').trim();
      if (value === '') {
        if (!optional && el.required) missing.push(label);
        return;
      }
      assignNestedValue(params, keyPath, value);
    });
    const hiddenDefaults = row.state.hiddenValues;
    if (hiddenDefaults && typeof hiddenDefaults === 'object') {
      mergeHiddenDefaults(params, hiddenDefaults);
    }
    row.state.missingFields = missing;
    return params;
  }

  function applyParameters(row, params) {
    if (!params || typeof params !== 'object') return;
    const container = row.elements.fieldsContainer;
    if (!container) return;
    const entries = [];
    const visit = (value, path) => {
      if (!path) return;
      if (value === null || value === undefined) {
        entries.push([path, value]);
        return;
      }
      if (Array.isArray(value)) {
        entries.push([path, value]);
        return;
      }
      if (typeof value === 'object') {
        Object.entries(value).forEach(([childKey, childValue]) => {
          const next = joinFieldKey(path, childKey);
          visit(childValue, next);
        });
        return;
      }
      entries.push([path, value]);
    };
    Object.entries(params).forEach(([rootKey, rootValue]) => {
      visit(rootValue, rootKey);
    });

    const fields = Array.from(container.querySelectorAll('[data-field-key]'));

    entries.forEach(([keyPath, value]) => {
      if (!keyPath) return;
      const field = fields.find((el) => el.dataset.fieldKey === keyPath);
      if (!field) return;
      const type = (field.dataset.fieldType || '').toLowerCase();
      if (type === 'boolean') {
        field.checked = !!value;
        field.dispatchEvent(new Event('change', { bubbles: true }));
        return;
      }
      if (type === 'singleimage' || type === 'singleimages' || type === 'multiimages' || type === 'multiimage') {
        if (typeof field.storySetValue === 'function') {
          field.storySetValue(value);
        }
        return;
      }
      const stringValue = value !== undefined && value !== null ? String(value) : '';
      if (field.tagName === 'SELECT') {
        field.value = stringValue;
        field.dispatchEvent(new Event('change', { bubbles: true }));
        return;
      }
      if (type === 'number') {
        field.value = stringValue;
        field.dispatchEvent(new Event('input', { bubbles: true }));
        return;
      }
      field.value = stringValue;
      field.dispatchEvent(new Event('input', { bubbles: true }));
    });

    ensureHiddenStore(row);
    if (row.state.hiddenFieldKeys instanceof Set && row.state.hiddenFieldKeys.size) {
      row.state.hiddenFieldKeys.forEach((path) => {
        if (!path) return;
        const hiddenValue = getNestedValue(params, path);
        if (hiddenValue !== undefined) assignNestedValue(row.state.hiddenValues, path, hiddenValue);
      });
    }
  }

  function buildPayload(params) {
    const payload = { ...params };
    if (payload.enable_safety_checker === undefined) payload.enable_safety_checker = true;
    if (payload.logs === undefined) payload.logs = true;
    return payload;
  }

  async function fetchWithTimeout(url, options, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { ...options, signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  async function pollFalQueue(row, endpoint, requestId, apiKey, timeoutMs, onUpdate, extraUrls, logsBase, outputType) {
    const started = Date.now();
    let lastProgress = started;
    let lastStatus = '';
    const base = endpoint.replace(/\/?$/, '');
    const builders = [
      (id) => `${base}/${id}`,
      (id) => `${base}/${id}/status`,
      (id) => `${base}/${id}/result`,
      (id) => `${base}/requests/${id}`,
      (id) => `${base}/requests/${id}/status`,
      (id) => `${base}/requests/${id}/result`
    ];

    let origin = '';
    let encodedPath = '';
    try {
      const urlObj = new URL(endpoint);
      origin = urlObj.origin;
      const normalizedPath = urlObj.pathname.replace(/(^\/|\/$)/g, '');
      if (normalizedPath) {
        encodedPath = normalizedPath.split('/').map(encodeURIComponent).join('/');
        builders.push((id) => `${origin}/v1/queues/${encodedPath}/requests/${id}`);
        builders.push((id) => `${origin}/v1/history/${encodedPath}/${id}`);
      }
      builders.push((id) => `${origin}/v1/requests/${id}`);
    } catch {}

    const extras = new Set(extraUrls || []);
    const seedExtras = [
      `${base}/${requestId}/status`,
      `${base}/${requestId}/result`,
      `${base}/requests/${requestId}`,
      `${base}/requests/${requestId}/status`,
      `${base}/requests/${requestId}/result`
    ];
    seedExtras.forEach((url) => extras.add(url));
    if (origin) extras.add(`${origin}/v1/requests/${requestId}`);
    if (origin && encodedPath) {
      extras.add(`${origin}/v1/queues/${encodedPath}/requests/${requestId}`);
      extras.add(`${origin}/v1/history/${encodedPath}/${requestId}`);
    }

    let logs = Array.isArray(logsBase) ? logsBase.slice() : [];
    const updateProgress = () => { lastProgress = Date.now(); };
    const addExtraUrl = (value) => {
      if (typeof value === 'string' && value.startsWith('http')) extras.add(value);
    };

    const tryFetch = async (targetUrl) => {
      if (!targetUrl) return null;
      const now = Date.now();
      const fetchWindow = Math.min(15000, Math.max(5000, timeoutMs - (now - lastProgress)));
      let res;
      try {
        res = await fetchWithTimeout(targetUrl, {
          method: 'GET',
          headers: {
            'Authorization': `Key ${apiKey}`,
            'Accept': 'application/json'
          },
          referrerPolicy: 'no-referrer',
          credentials: 'omit'
        }, fetchWindow);
      } catch (err) {
        if (err?.name === 'AbortError') return null;
        throw err;
      }
      if (!res.ok) {
        if (res.status === 404 || res.status === 401 || res.status === 403) return null;
        return null;
      }
      const text = await res.text();
      if (!text) return null;
      let data;
      try { data = JSON.parse(text); }
      catch { return null; }

      if (typeof onUpdate === 'function' && row.state.isGenerating) onUpdate(data);
      updateProgress();

      const info = extractStoryboardResult(outputType, data);
      const before = logs.length;
      logs = mergeLogs(logs, info.logs);
      if (logs.length !== before) updateProgress();
      if (Array.isArray(info?.extraUrls)) info.extraUrls.forEach(addExtraUrl);

      const status = info.status || getStatusString(data);
      if (status) {
        const normalized = status.toUpperCase();
        if (normalized.includes('FAILED') || normalized.includes('CANCEL')) {
          throw new Error(`FALリクエストが失敗しました (${status})`);
        }
        if (status !== lastStatus) {
          lastStatus = status;
          updateProgress();
        }
      }

      if (info.ready) return { info, logs };
      return null;
    };

    const maxOverall = Math.max(timeoutMs * 3, timeoutMs + 180000);
    while (true) {
      if (row.state.isCanceled) throw new Error('キャンセルしました');
      let result = null;
      for (const build of builders) {
        if (row.state.isCanceled) throw new Error('キャンセルしました');
        try {
          result = await tryFetch(build(requestId));
          if (result) return result;
        } catch (err) {
          if (err?.name === 'AbortError') continue;
          throw err;
        }
      }

      for (const url of Array.from(extras)) {
        if (row.state.isCanceled) throw new Error('キャンセルしました');
        try {
          result = await tryFetch(url);
          if (result) return result;
        } catch (err) {
          if (err?.name === 'AbortError') continue;
          throw err;
        }
      }

      const now = Date.now();
      if (now - lastProgress > timeoutMs) {
        const idleSec = Math.round((now - lastProgress) / 1000);
        throw new Error(`FALレスポンスが${idleSec}秒間更新されませんでした。`);
      }
      if (now - started > maxOverall) {
        throw new Error(`生成がタイムアウトしました (request ${requestId})`);
      }

      await sleep(1200);
    }
  }

  async function runFalModel(row, entry, params, apiKey) {
    const endpoint = (entry?.endpoint || '').trim();
    if (!endpoint) throw new Error('モデルのエンドポイントが設定されていません。');
    const timeoutMs = Math.max(Number(entry?.timeoutSec || 90) * 1000, 10000);
    const useQueue = /queue\.fal\.run/i.test(endpoint);
    const payload = buildPayload(params);
    if (row.state.isCanceled) throw new Error('キャンセルしました');
    const body = useQueue ? payload : { input: payload };
    const outputType = normalizeOutputType(entry?.output || row.state.outputType);
    setRowOutputType(row, outputType);

    const response = await fetchWithTimeout(endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Key ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body),
      referrerPolicy: 'no-referrer',
      credentials: 'omit'
    }, timeoutMs);

    const raw = await response.text();
    if (!response.ok) {
      let errorMessage = `HTTP ${response.status}`;
      try {
        const data = raw ? JSON.parse(raw) : {};
        errorMessage = data?.error?.message || data?.error || data?.message || errorMessage;
      } catch {}
      throw new Error(errorMessage || 'リクエストに失敗しました。');
    }

    let data = {};
    try { data = raw ? JSON.parse(raw) : {}; }
    catch { throw new Error('レスポンスの解析に失敗しました。'); }

    if (row.state.isGenerating) handleUpdate(row, data);
    if (row.state.isCanceled) throw new Error('キャンセルしました');

    const info = extractStoryboardResult(outputType, data);
    if (info.ready) return { info, logs: info.logs };

    const requestId = data?.request_id || data?.requestId || data?.id;
    if (!useQueue) throw new Error('生成結果を含むレスポンスを取得できませんでした。');
    if (!requestId) throw new Error('キューのリクエストIDが取得できませんでした。');

    const result = await pollFalQueue(row, endpoint, requestId, apiKey, timeoutMs, (update) => handleUpdate(row, update), info.extraUrls, info.logs, outputType);
    return result;
  }

  function handleUpdate(row, data) {
    const info = extractStoryboardResult(row?.state?.outputType || 'video', data);
    row.state.aggregatedLogs = mergeLogs(row.state.aggregatedLogs, info.logs);
    showLogs(row, row.state.aggregatedLogs);
    if (!row.state.isGenerating) return;
    if (info.status) {
      const label = info.status.replace(/_/g, ' ');
      setStatus(row, `ステータス: ${label}`, 'info');
    }
  }

  async function getFalApiKey() {
    const read = async (source) => new Promise((resolve) => {
      try {
        source.get(['falApiKey'], (value) => resolve(value?.falApiKey || ''));
      } catch (err) {
        resolve('');
      }
    });
    let key = '';
    if (chrome?.storage?.session) key = await read(chrome.storage.session);
    if (!key && chrome?.storage?.local) key = await read(chrome.storage.local);
    return key.trim();
  }

  function populateRowModels(row) {
    const select = row.elements.modelSelect;
    if (!select) return;
    const preserved = select.value;
    while (select.options.length > 1) select.remove(1);
    let anySelected = false;
    storyboardModels.forEach((entry) => {
      const opt = document.createElement('option');
      opt.value = `${entry.provider || 'unknown'}:${entry.model || ''}`;
      opt.textContent = entry.label || opt.value;
      if (entry.default === true && !anySelected) {
        opt.selected = true;
        anySelected = true;
      }
      select.appendChild(opt);
    });
    if (preserved && Array.from(select.options).some((opt) => opt.value === preserved)) {
      select.value = preserved;
    } else if (!select.value && select.options.length > 1) {
      select.selectedIndex = 1;
    }
  }

  function buildJobFilename(row, rawTitle, extension = 'mp4') {
    const sequence = Number(row?.state?.sequence) || Number(row?.id?.replace('row-', '')) || 1;
    const jobSegment = `job_${sequence}`;
    const titleSource = typeof rawTitle === 'string' ? rawTitle : '';
    const normalized = titleSource && typeof titleSource.normalize === 'function'
      ? titleSource.normalize('NFKC')
      : titleSource;
    const collapsed = normalized.trim().replace(/\s+/g, '_');
    const sanitized = collapsed
      .replace(/[^\p{Letter}\p{Number}_-]+/gu, '_')
      .replace(/_{2,}/g, '_')
      .replace(/^_|_$/g, '')
      .toLowerCase();
    const safeExt = (extension || 'mp4').toString().replace(/[^a-z0-9.]+/gi, '').replace(/^\.+/, '').toLowerCase() || 'bin';
    const titleSegment = sanitized || safeExt;
    return `${jobSegment}_${titleSegment}.${safeExt}`;
  }

  function guessExtensionFromMime(mime, fallback = 'bin') {
    const map = {
      'image/png': 'png',
      'image/jpeg': 'jpg',
      'image/jpg': 'jpg',
      'image/webp': 'webp',
      'image/gif': 'gif',
      'image/bmp': 'bmp',
      'audio/mpeg': 'mp3',
      'audio/wav': 'wav',
      'audio/x-wav': 'wav',
      'audio/ogg': 'ogg',
      'audio/mp4': 'm4a',
      'audio/x-m4a': 'm4a',
      'audio/webm': 'webm'
    };
    const key = (mime || '').toString().trim().toLowerCase();
    return map[key] || fallback;
  }

  function guessExtensionFromUrl(url, fallback = 'bin') {
    if (typeof url !== 'string') return fallback;
    const match = url.split('?')[0].split('#')[0].match(/\.([a-z0-9]+)$/i);
    if (match && match[1]) return match[1].toLowerCase();
    return fallback;
  }

  async function fetchMediaBlob(source, fallbackMime = 'application/octet-stream') {
    if (!source) return null;
    const src = source.toString();
    try {
      const res = await fetch(src, { mode: 'cors', credentials: 'omit' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.blob();
    } catch (err) {
      if (/^data:/i.test(src)) {
        const res = await fetch(src);
        if (!res.ok) throw err;
        return await res.blob();
      }
      if (typeof source === 'object' && source.dataUrl) {
        const res = await fetch(source.dataUrl);
        if (!res.ok) throw err;
        return await res.blob();
      }
      if (typeof source === 'object' && source.base64) {
        const dataUrl = toDataUrlFromBase64(source.base64, fallbackMime);
        if (dataUrl) {
          const res = await fetch(dataUrl);
          if (!res.ok) throw err;
          return await res.blob();
        }
      }
      throw err;
    }
  }

  async function convertBlobToPng(blob) {
    if (!blob) return null;
    if ((blob.type || '').toLowerCase() === 'image/png') return blob;
    const dataUrl = await blobToDataUrl(blob);
    const img = await loadImageFromDataUrl(dataUrl);
    const canvas = document.createElement('canvas');
    canvas.width = img.width || 1;
    canvas.height = img.height || 1;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas コンテキストの作成に失敗しました。');
    ctx.drawImage(img, 0, 0);
    return new Promise((resolve, reject) => {
      canvas.toBlob((png) => {
        if (png) resolve(png);
        else reject(new Error('PNG への変換に失敗しました。'));
      }, 'image/png');
    });
  }

  async function downloadBlob(blob, filename) {
    const objectUrl = URL.createObjectURL(blob);
    const attempt = chrome?.downloads?.download;
    const fallback = async () => {
      const anchor = document.createElement('a');
      anchor.href = objectUrl;
      anchor.download = filename;
      anchor.rel = 'noopener';
      document.body.appendChild(anchor);
      anchor.click();
      anchor.remove();
    };
    try {
      if (typeof attempt === 'function') {
        await new Promise((resolve, reject) => {
          attempt({ url: objectUrl, filename, saveAs: false }, (downloadId) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
              return;
            }
            resolve(downloadId);
          });
        });
      } else {
        await fallback();
      }
    } catch (err) {
      console.warn('downloadBlob fallback', err);
      await fallback();
    } finally {
      setTimeout(() => URL.revokeObjectURL(objectUrl), 4000);
    }
  }

  async function handleDownload(row) {
    const url = getVideoResult(row)?.videos?.[0]?.url || '';
    if (!url) return;
    const rawTitle = (row.elements.controlTitle?.value || '').trim();
    const filename = buildJobFilename(row, rawTitle);
    const downloadAttempt = chrome?.downloads?.download;
    const downloadBtn = row.state.videoControls?.downloadBtn || null;
    setStatus(row, '動画を準備しています...', 'info');
    if (downloadBtn) downloadBtn.disabled = true;

    if (typeof downloadAttempt === 'function') {
      try {
        await new Promise((resolve, reject) => {
          downloadAttempt({ url, filename, saveAs: false }, (downloadId) => {
            if (chrome.runtime.lastError) {
              reject(new Error(chrome.runtime.lastError.message));
              return;
            }
            resolve(downloadId);
          });
        });
      setStatus(row, '動画のダウンロードを開始しました。', 'success', { duration: 1800 });
      return;
    } catch (err) {
      console.warn('Download API failed, falling back to fetch', err);
    }
    }

    try {
      const res = await fetch(url, { mode: 'cors', credentials: 'omit' });
      if (!res.ok) throw new Error('動画の取得に失敗しました。');
      const blob = await res.blob();
      const objectUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = objectUrl;
      a.download = filename;
      a.rel = 'noopener';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(objectUrl), 4000);
      setStatus(row, '動画のダウンロードを開始しました。', 'success', { duration: 1800 });
    } catch (err) {
      console.error('Failed to trigger download', err);
      setStatus(row, err?.message || 'ダウンロードに失敗しました。', 'error', { duration: 2600 });
      try { window.open(url, '_blank'); }
      catch (e) { console.error('Fallback open failed', e); }
    } finally {
      if (downloadBtn) downloadBtn.disabled = false;
    }
  }

  async function handleDownloadImage(row, index = 0, button) {
    const result = getImageResult(row);
    const images = result?.images || [];
    const image = images[index];
    if (!image) {
      setStatus(row, 'ダウンロードできる画像がありません。', 'error', { duration: 2000 });
      return;
    }
    const src = image?.src || image?.dataUrl || image?.url;
    if (!src) {
      setStatus(row, 'ダウンロードできる画像がありません。', 'error', { duration: 2000 });
      return;
    }
    const mime = image?.mime || (src.startsWith('data:') ? src.split(';')[0].split(':')[1] : 'image/png');
    const ext = mime ? guessExtensionFromMime(mime, guessExtensionFromUrl(src, 'png')) : guessExtensionFromUrl(src, 'png');
    const rawTitle = (row.elements.controlTitle?.value || '').trim();
    const filename = buildJobFilename(row, rawTitle || image?.name, ext || 'png');
    try {
      setStatus(row, '画像を準備しています...', 'info');
      if (button) button.disabled = true;
      const blob = await fetchMediaBlob(src, mime || 'image/png');
      if (!blob) throw new Error('画像の取得に失敗しました。');
      await downloadBlob(blob, filename);
      setStatus(row, '画像のダウンロードを開始しました。', 'success', { duration: 1800 });
    } catch (err) {
      console.error('Failed to download image', err);
      setStatus(row, err?.message || '画像のダウンロードに失敗しました。', 'error', { duration: 2600 });
    } finally {
      if (button) button.disabled = false;
    }
  }

  async function handleCopyImage(row, index = 0, button) {
    if (!navigator?.clipboard?.write || typeof ClipboardItem === 'undefined') {
      setStatus(row, 'クリップボードに画像をコピーできません。', 'error', { duration: 2400 });
      return;
    }
    const result = getImageResult(row);
    const image = result?.images?.[index];
    if (!image) {
      setStatus(row, 'コピーできる画像がありません。', 'error', { duration: 2200 });
      return;
    }
    const src = image?.src || image?.dataUrl || image?.url;
    if (!src) {
      setStatus(row, 'コピーできる画像がありません。', 'error', { duration: 2200 });
      return;
    }
    try {
      setStatus(row, '画像をコピーしています...', 'info');
      if (button) button.disabled = true;
      const blob = await fetchMediaBlob(src, image?.mime || 'image/png');
      if (!blob) throw new Error('画像の取得に失敗しました。');
      const pngBlob = await convertBlobToPng(blob);
      const item = new ClipboardItem({ [pngBlob.type || 'image/png']: pngBlob });
      await navigator.clipboard.write([item]);
      setStatus(row, '画像をコピーしました。', 'success', { duration: 2000 });
    } catch (err) {
      console.error('Failed to copy image', err);
      setStatus(row, err?.message || '画像のコピーに失敗しました。', 'error', { duration: 2600 });
    } finally {
      if (button) button.disabled = false;
    }
  }

  async function openImagePreview(row, index = 0) {
    const result = getImageResult(row);
    const image = result?.images?.[index];
    const src = image?.src || image?.dataUrl || image?.url;
    if (!src) {
      setStatus(row, 'プレビューできる画像がありません。', 'error', { duration: 2200 });
      return;
    }
    try {
      setStatus(row, 'プレビューを開いています...', 'info');
      await openImagePopup(src);
      setStatus(row, 'プレビューを開きました。', 'success', { duration: 1500 });
    } catch (err) {
      console.error('Failed to open image preview', err);
      setStatus(row, err?.message || 'プレビューを開けませんでした。', 'error', { duration: 2600 });
    }
  }

  async function handleDownloadAudio(row, index = 0, button) {
    const result = getAudioResult(row);
    const audios = result?.audios || [];
    const audio = audios[index];
    const src = audio?.src || audio?.dataUrl || audio?.url;
    if (!src) {
      setStatus(row, 'ダウンロードできる音声がありません。', 'error', { duration: 2000 });
      return;
    }
    const mime = audio?.mime || (src.startsWith('data:') ? src.split(';')[0].split(':')[1] : 'audio/mpeg');
    const ext = mime ? guessExtensionFromMime(mime, guessExtensionFromUrl(src, 'mp3')) : guessExtensionFromUrl(src, 'mp3');
    const rawTitle = (row.elements.controlTitle?.value || '').trim();
    const filename = buildJobFilename(row, rawTitle || audio?.name, ext || 'mp3');
    try {
      setStatus(row, '音声を準備しています...', 'info');
      if (button) button.disabled = true;
      const blob = await fetchMediaBlob(src, mime || 'audio/mpeg');
      if (!blob) throw new Error('音声の取得に失敗しました。');
      await downloadBlob(blob, filename);
      setStatus(row, '音声のダウンロードを開始しました。', 'success', { duration: 1800 });
    } catch (err) {
      console.error('Failed to download audio', err);
      setStatus(row, err?.message || '音声のダウンロードに失敗しました。', 'error', { duration: 2600 });
    } finally {
      if (button) button.disabled = false;
    }
  }

  function handleCancel(row) {
    if (!row.state.isGenerating) return;
    row.state.isCanceled = true;
    setStatus(row, 'キャンセルしています...', 'info');
    updateControlNote(row, 'Canceling...');
  }

  async function handleCopy(row) {
    const url = getVideoResult(row)?.videos?.[0]?.url || '';
    if (!url) return;
    const copyBtn = row.state.videoControls?.copyBtn || null;
    if (copyBtn) copyBtn.disabled = true;
    try {
      setStatus(row, 'フレームをコピーしています...', 'info');
      await copyFrameToClipboard(row);
      setStatus(row, '停止中のフレームをコピーしました。', 'success', { duration: 2000 });
    } catch (err) {
      console.error('Copy frame failed', err);
      const message = err?.message || 'フレームのコピーに失敗しました。';
      setStatus(row, message, 'error', { duration: 2600 });
    } finally {
      if (copyBtn) copyBtn.disabled = !getVideoResult(row)?.videos?.[0]?.url;
    }
  }

  function clampTime(video, time) {
    return Math.max(0, Math.min(video.duration || Number.MAX_SAFE_INTEGER, time));
  }

  function stepFrame(row, direction) {
    const state = ensureRowVideoState(row);
    const video = state.videoElement;
    if (!video) return;
    const duration = Math.max(state.frameDuration || 1 / 30, 1 / 60);
    const delta = duration * direction;
    const target = clampTime(video, video.currentTime + delta);
    video.currentTime = target;
  }

  function resetFrame(row) {
    const state = ensureRowVideoState(row);
    const video = state.videoElement;
    if (!video) return;
    const base = state.originalTime ?? 0;
    video.currentTime = clampTime(video, base);
  }

  async function handleGenerate(row) {
    if (row.state.isGenerating) return;
    if (!modelsLoaded || !storyboardModels.length) {
      setStatus(row, 'モデル定義が読み込まれていません。数秒後に再度お試しください。', 'error');
      return;
    }
    const select = row.elements.modelSelect;
    const modelValue = select?.value || '';
    const entry = findModelByValue(modelValue);
    if (!entry) {
      setStatus(row, 'モデルを選択してください。', 'error');
      return;
    }

    row.state.missingFields = [];
    const params = collectParameters(row);
    const missing = Array.isArray(row.state.missingFields)
      ? row.state.missingFields.filter(Boolean)
      : [];
    if (missing.length) {
      const message = `${missing.join(', ')} を設定してください。`;
      setStatus(row, message, 'error');
      return;
    }

    const fieldDefs = flattenFieldDefs(Array.isArray(entry?.inputs) ? entry.inputs : Array.isArray(entry?.prompt) ? entry.prompt : [], '');
    const promptField = fieldDefs.find((item) => !item?.container && (item?.def?.key || '').toLowerCase() === 'prompt');
    const promptIsOptional = promptField?.def?.optional === true;
    const promptExplicitOptional = promptField?.def?.required === false;
    const promptRequired = !!promptField && !promptIsOptional && !promptExplicitOptional;
    if (promptRequired) {
      const promptValue = getNestedValue(params, promptField.key);
      const hasPrompt = Array.isArray(promptValue)
        ? promptValue.length > 0
        : typeof promptValue === 'string'
          ? promptValue.trim().length > 0
          : promptValue !== undefined && promptValue !== null;
      if (!hasPrompt) {
        setStatus(row, 'プロンプトを入力してください。', 'error');
        return;
      }
    }

    const apiKey = await getFalApiKey();
    if (!apiKey) {
      setStatus(row, 'FAL APIキーが設定されていません。設定ページで入力してください。', 'error');
      return;
    }

    const outputType = normalizeOutputType(entry?.output || row.state.outputType);
    setRowOutputType(row, outputType);

    row.state.isCanceled = false;
    row.state.aggregatedLogs = [];
    showLogs(row, []);
    clearResult(row);
    setBusy(row, true);
    const runningMessage = outputType === 'audio'
      ? '音声を生成しています...'
      : outputType === 'image'
        ? '画像を生成しています...'
        : '動画を生成しています...';
    setStatus(row, runningMessage, 'info');
    updateControlNote(row, 'Running...');

    try {
      const result = await runFalModel(row, entry, params, apiKey);
      const info = result?.info || null;
      if (!info) throw new Error('生成結果を取得できませんでした。');
      const resolvedType = normalizeOutputType(info.type || outputType);
      row.state.aggregatedLogs = mergeLogs(row.state.aggregatedLogs, result.logs || []);
      if (resolvedType === 'image') {
        renderImages(row, info, { modelLabel: entry.label });
      } else if (resolvedType === 'audio') {
        renderAudio(row, info, { modelLabel: entry.label });
      } else {
        const videos = Array.isArray(info?.videos) ? info.videos : [];
        const primary = videos.find((item) => item?.url) || {};
        renderVideo(row, primary.url || '', { modelLabel: entry.label });
      }
      showLogs(row, row.state.aggregatedLogs);
      const doneMessage = resolvedType === 'audio'
        ? '音声の生成が完了しました。'
        : resolvedType === 'image'
          ? '画像の生成が完了しました。'
          : '動画の生成が完了しました。';
      setStatus(row, doneMessage, 'success', { duration: 2000 });
      updateControlNote(row, 'Completed');
    } catch (err) {
      console.error('[StoryBoard] generate failed', err);
      showLogs(row, row.state.aggregatedLogs);
      const message = err?.message || '生成に失敗しました。';
      if (row.state.isCanceled || message.includes('キャンセル')) {
        setStatus(row, 'キャンセルしました。', 'info', { duration: 2000 });
        updateControlNote(row, 'Canceled');
      } else {
        setStatus(row, message, 'error');
        updateControlNote(row, 'Failed');
      }
    } finally {
      setBusy(row, false);
      row.state.isCanceled = false;
      updateControlButtons();
    }
  }

  function removeRow(row) {
    if (!row || !rows.has(row.id)) return;
    if (row.state.isGenerating) {
      setStatus(row, '生成中のジョブは削除できません。', 'error', { duration: 2400 });
      return;
    }
    rows.delete(row.id);
    if (row.root?.parentNode === rowsContainer) rowsContainer.removeChild(row.root);
    reindexRows();
    updateControlButtons();
    refreshDownloadAllState();
    if (!rows.size) {
      const fallback = createRow();
      fallback.root.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  function duplicateRow(row) {
    if (!row || !rows.has(row.id)) return;
    if (!modelsLoaded || !storyboardModels.length) {
      setStatus(row, 'モデル定義が読み込まれていません。数秒後に再度お試しください。', 'error');
      return;
    }

    const modelValue = row.elements.modelSelect?.value || '';
    const params = collectParameters(row);
    const title = row.elements.controlTitle?.value || '';
    const memo = row.elements.controlMemo?.value || '';

    const newRow = createRow({ insertAfter: row });

    if (modelValue && newRow.elements.modelSelect) {
      const hasOption = Array.from(newRow.elements.modelSelect.options).some((opt) => opt.value === modelValue);
      if (hasOption) {
        newRow.elements.modelSelect.value = modelValue;
      }
    }

    renderFields(newRow);

    applyParameters(newRow, params);
    if (newRow.elements.controlTitle) newRow.elements.controlTitle.value = title;
    if (newRow.elements.controlMemo) newRow.elements.controlMemo.value = memo;
    updateControlNote(newRow, 'Idle');
    setStatus(newRow, '複製しました。', 'success', { duration: 1200 });
    if (row.state.isGenerating) {
      setStatus(row, '生成中に複製を作成しました。', 'info', { duration: 1600 });
    }
    highlightRow(newRow);
    refreshDownloadAllState();
  }

  function setupRow(row) {
    const selectId = `${row.id}-model`;
    row.elements.modelSelect.id = selectId;
    row.elements.modelLabel.setAttribute('for', selectId);

    addControlEntry(row, `Job ${row.state.sequence}`, 'Idle');
    showLogs(row, []);

    row.elements.modelSelect.addEventListener('change', () => renderFields(row));
    row.elements.generateBtn.addEventListener('click', () => handleGenerate(row));
    row.elements.cancelBtn.addEventListener('click', () => handleCancel(row));
    row.elements.controlDuplicate.addEventListener('click', () => duplicateRow(row));
    if (row.elements.controlMoveUp) {
      row.elements.controlMoveUp.addEventListener('click', () => moveRow(row, -1));
    }
    if (row.elements.controlMoveDown) {
      row.elements.controlMoveDown.addEventListener('click', () => moveRow(row, 1));
    }
    row.elements.controlAdd.addEventListener('click', () => {
      const newRow = createRow({ insertAfter: row });
      newRow.root.scrollIntoView({ behavior: 'smooth', block: 'start' });
      highlightRow(newRow);
    });
    row.elements.controlRemove.addEventListener('click', () => {
      const confirmed = window.confirm('消しても良いですか？');
      if (!confirmed) return;
      removeRow(row);
    });

    if (modelsLoaded) {
      populateRowModels(row);
      renderFields(row);
    }
  }

  async function handleDownloadAll() {
    if (zipBusy) return;
    const downloadables = Array.from(rows.values())
      .map((row) => ({ row, result: row.state.result }))
      .filter(({ result }) => {
        if (!result) return false;
        if (result.type === 'video') return Array.isArray(result.videos) && result.videos.some((item) => item?.url);
        if (result.type === 'image') return Array.isArray(result.images) && result.images.length > 0;
        if (result.type === 'audio') return Array.isArray(result.audios) && result.audios.length > 0;
        return false;
      });
    if (!downloadables.length) {
      refreshDownloadAllState();
      return;
    }

    setZipBusy(true, 'ZIPを準備しています...');
    const zip = new ZipWriter();
    const processed = [];
    let objectUrl = '';

    try {
      for (const { row, result } of downloadables) {
        const rawTitle = row.elements.controlTitle?.value || '';
        if (result.type === 'video') {
          const videos = Array.isArray(result.videos) ? result.videos : [];
          const primary = videos.find((item) => item?.url) || videos[0];
          if (!primary?.url) {
            setStatus(row, 'ZIPに追加できる動画がありませんでした。', 'error', { duration: 2600 });
            continue;
          }
          setStatus(row, '動画をZIPに追加しています...', 'info');
          const blob = await fetchMediaBlob(primary.url, 'video/mp4');
          if (!blob) throw new Error('動画の取得に失敗しました。');
          const extension = guessExtensionFromUrl(primary.url, 'mp4');
          const filename = buildJobFilename(row, rawTitle, extension || 'mp4');
          const data = new Uint8Array(await blob.arrayBuffer());
          zip.add(filename, data);
          processed.push(row);
          setStatus(row, 'ZIPに追加しました。', 'success', { duration: 1600 });
          continue;
        }

        if (result.type === 'image') {
          const images = Array.isArray(result.images) ? result.images : [];
          if (!images.length) continue;
          let added = 0;
          for (let index = 0; index < images.length; index += 1) {
            const item = images[index];
            const src = item?.src || item?.dataUrl || item?.url;
            if (!src) continue;
            setStatus(row, `画像をZIPに追加しています... (${index + 1}/${images.length})`, 'info');
            const mime = item?.mime || (src.startsWith('data:') ? src.split(';')[0].split(':')[1] : 'image/png');
            const blob = await fetchMediaBlob(src, mime || 'image/png');
            if (!blob) continue;
            const extFromMime = mime ? guessExtensionFromMime(mime, 'png') : 'png';
            const extension = extFromMime || guessExtensionFromUrl(src, 'png');
            const titleForFile = rawTitle
              ? `${rawTitle} ${index + 1}`
              : item?.name || `image_${index + 1}`;
            const filename = buildJobFilename(row, titleForFile, extension || 'png');
            const data = new Uint8Array(await blob.arrayBuffer());
            zip.add(filename, data);
            added += 1;
          }
          if (added > 0) {
            processed.push(row);
            setStatus(row, 'ZIPに追加しました。', 'success', { duration: 1600 });
          } else {
            setStatus(row, 'ZIPに追加できる画像がありませんでした。', 'error', { duration: 2600 });
          }
          continue;
        }

        if (result.type === 'audio') {
          const audios = Array.isArray(result.audios) ? result.audios : [];
          if (!audios.length) continue;
          const primary = audios[0];
          const src = primary?.src || primary?.dataUrl || primary?.url;
          if (!src) {
            setStatus(row, 'ZIPに追加できる音声がありませんでした。', 'error', { duration: 2600 });
            continue;
          }
          setStatus(row, '音声をZIPに追加しています...', 'info');
          const mime = primary?.mime || (src.startsWith('data:') ? src.split(';')[0].split(':')[1] : 'audio/mpeg');
          const blob = await fetchMediaBlob(src, mime || 'audio/mpeg');
          if (!blob) throw new Error('音声の取得に失敗しました。');
          const extension = mime ? guessExtensionFromMime(mime, guessExtensionFromUrl(src, 'mp3')) : guessExtensionFromUrl(src, 'mp3');
          const filename = buildJobFilename(row, rawTitle || primary?.name, extension || 'mp3');
          const data = new Uint8Array(await blob.arrayBuffer());
          zip.add(filename, data);
          processed.push(row);
          setStatus(row, 'ZIPに追加しました。', 'success', { duration: 1600 });
        }
      }

      const blob = zip.generate();
      const zipName = `storyboard_results_${new Date().toISOString().replace(/[-:.TZ]/g, '').slice(0, 14)}.zip`;
      objectUrl = URL.createObjectURL(blob);

      let downloaded = false;
      if (typeof chrome?.downloads?.download === 'function') {
        try {
          await new Promise((resolve, reject) => {
            chrome.downloads.download({ url: objectUrl, filename: zipName, saveAs: false }, (downloadId) => {
              if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
                return;
              }
              resolve(downloadId);
            });
          });
          downloaded = true;
        } catch (err) {
          console.warn('chrome.downloads.download failed, falling back', err);
        }
      }

      if (!downloaded) {
        const anchor = document.createElement('a');
        anchor.href = objectUrl;
        anchor.download = zipName;
        anchor.rel = 'noopener';
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();
      }

      processed.forEach((row) => setStatus(row, 'ZIPのダウンロードを開始しました。', 'success', { duration: 2000 }));
    } catch (err) {
      console.error('[StoryBoard] download all failed', err);
      const message = err?.message || 'ZIPの作成に失敗しました。';
      downloadables.forEach(({ row }) => setStatus(row, message, 'error', { duration: 2600 }));
    } finally {
      if (objectUrl) {
        setTimeout(() => URL.revokeObjectURL(objectUrl), 4000);
      }
      setZipBusy(false);
    }
  }

  function createRow(options = {}) {
    const fragment = rowTemplate.content.cloneNode(true);
    const rowEl = fragment.querySelector('.storyboard-row');
    if (!rowEl) throw new Error('Row template missing root element');
    const rowId = `row-${++rowSeq}`;
    const sequence = rowSeq;
    rowEl.dataset.rowId = rowId;

    const elements = {
      root: rowEl,
      track: rowEl.querySelector('.storyboard-track'),
      controlList: rowEl.querySelector('.control-list'),
      controlMoveUp: rowEl.querySelector('.control-move-up'),
      controlMoveDown: rowEl.querySelector('.control-move-down'),
      controlAdd: rowEl.querySelector('.control-add'),
      controlRemove: rowEl.querySelector('.control-remove'),
      controlDuplicate: rowEl.querySelector('.control-duplicate'),
      controlEntry: null,
      controlLabel: null,
      controlNote: null,
      modelGroup: rowEl.querySelector('.model-group'),
      modelLabel: rowEl.querySelector('.model-label'),
      modelSelect: rowEl.querySelector('.story-model'),
      generateBtn: rowEl.querySelector('.story-generate'),
      cancelBtn: rowEl.querySelector('.story-cancel'),
      status: rowEl.querySelector('.story-status'),
      fieldsContainer: rowEl.querySelector('.story-fields'),
      output: rowEl.querySelector('.story-output'),
      logsWrapper: rowEl.querySelector('.story-logs'),
      logsBody: rowEl.querySelector('.story-logs-body')
    };

    const state = {
      sequence,
      aggregatedLogs: [],
      isGenerating: false,
      statusTimer: null,
      isCanceled: false,
      missingFields: [],
      hiddenValues: {},
      hiddenFieldKeys: new Set(),
      outputType: 'video',
      result: null,
      videoControls: null,
      audioControls: null
    };

    const row = { id: rowId, root: rowEl, elements, state };
    rows.set(rowId, row);

    if (options?.insertAfter && options.insertAfter.root?.parentNode === rowsContainer) {
      rowsContainer.insertBefore(rowEl, options.insertAfter.root.nextSibling);
    } else {
      rowsContainer.appendChild(rowEl);
    }

    setupRow(row);
    reindexRows();
    updateControlButtons();
    refreshDownloadAllState();
    updateResultActions(row);
    return row;
  }

  async function loadModels() {
    try {
      const url = chrome.runtime.getURL('models_sb.json');
      const res = await fetch(url);
      if (!res.ok) throw new Error('models not found');
      const list = await res.json();
      storyboardModels = Array.isArray(list) ? list : [];
      modelsLoaded = true;
      rows.forEach((row) => {
        populateRowModels(row);
        renderFields(row);
      });
    } catch (err) {
      console.error('Failed to load models_sb.json', err);
      rows.forEach((row) => setStatus(row, 'モデル定義の読み込みに失敗しました。', 'error'));
    }
  }

  refreshDownloadAllState();
  downloadAllBtn?.addEventListener('click', () => handleDownloadAll());

  const initialRow = createRow();
  renderFields(initialRow);
  loadModels();
});
